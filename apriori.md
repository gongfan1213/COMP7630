Apriori算法是一种用于挖掘频繁项集和关联规则的经典算法，常用于数据挖掘领域，比如购物篮分析等场景。以下结合你提供的图片详细讲解：

### 初始数据集与参数设定
- **数据集**：给出了一个交易数据集，包含5条交易记录（T1 - T5），每条记录包含不同的商品项（Items） 。例如T1包含商品项1、3、4。
- **最小支持度（minsup）**：设定为40% 。在这个例子中，将支持度简化为被给定项集覆盖的交易记录数，因为总共有5条交易记录，40% 即至少要覆盖2条交易记录。 

### 步骤一：生成长度为1的候选项集（C1）
- 对数据集中出现的每个单项商品分别统计其在交易记录中出现的次数（即支持度）。
    - 项集{1}出现在T1、T3、T5中，支持度为3。
    - 项集{2}出现在T2、T3、T4中，支持度为3。
    - 项集{3}出现在T1、T2、T3、T5中，支持度为4。
    - 项集{4}出现在T1中，支持度为1。 
    - 项集{5}出现在T2、T3、T4、T5中，支持度为4。 

### 步骤二：筛选长度为1的频繁项集（F1）
- 根据最小支持度40%（支持度至少为2），筛选掉支持度小于2的项集。
- 项集{4}支持度为1，小于2，被过滤掉。
- 得到频繁项集F1，包含{1}（支持度3）、{2}（支持度3）、{3}（支持度4）、{5}（支持度4） 。 

### 步骤三：生成长度为2的候选项集（C2）并筛选频繁项集（F2）
- **生成C2**：利用F1中的项集生成所有可能的长度为2的组合。例如，从F1中的{1}、{2}、{3}、{5}生成{1,2}、{1,3}、{1,5}、{2,3}、{2,5}、{3,5} 。
- **计算支持度并筛选**：分别统计这些项集在交易记录中出现的次数。
    - {1,2}出现在T3中，支持度为1。
    - {1,3}出现在T1、T3、T5中，支持度为3。
    - {1,5}出现在T3、T5中，支持度为2。
    - {2,3}出现在T2、T3中，支持度为2。
    - {2,5}出现在T2、T3、T4中，支持度为3。
    - {3,5}出现在T2、T3、T5中，支持度为3。
- 过滤掉支持度小于2的项集{1,2}，得到频繁项集F2，包含{1,3}（支持度3）、{1,5}（支持度2）、{2,3}（支持度2）、{2,5}（支持度3）、{3,5}（支持度3） 。 

### 步骤四：生成长度为3的候选项集（C3）并筛选频繁项集（F3）
- **生成C3**：利用F2中的项集生成所有可能的长度为3的组合。
    - 生成{1,2,3}、{1,2,5}、{1,3,5}、{2,3,5} 。
    - 检查这些项集的子集是否都在F2中，{1,2,3}和{1,2,5}中有子集{1,2}不在F2中，被标记为NO；{1,3,5}和{2,3,5}的所有子集都在F2中，被标记为YES 。
- **计算支持度并筛选**：统计{1,3,5}和{2,3,5}的支持度。
    - {1,3,5}出现在T3、T5中，支持度为2。
    - {2,3,5}出现在T2、T3中，支持度为2。
- 得到频繁项集F3，包含{1,3,5}（支持度2）、{2,3,5}（支持度2） 。 

### 步骤五：生成长度为4的候选项集（C4）并结束算法
- **生成C4**：利用F3中的项集生成所有可能的长度为4的组合，得到{1,2,3,5} 。
- 统计其支持度，{1,2,3,5}出现在T3中，支持度为1，小于2，被过滤掉。
- 由于C4中所有候选项集都被过滤掉，算法终止。最终结果是F1、F2、F3的并集，即所有筛选出来的频繁项集 。 



Apriori算法基于“频繁项集的所有非空子集也一定是频繁的”这一先验性质，通过不断迭代生成候选项集并筛选出频繁项集，最终得到满足最小支持度的所有频繁项集。 
